/*
 *  FloppyController.java
 *  Joris van Rantwijk
 */

package retro;

/**
 * Simulation of an I8272 Floppy Disk Controller and Digital Output Register.
 *
 * <p>
 * The main component of the IBM PC diskette controller is an Intel 8272A,
 * programmed through ports 0x3F4 and 0x3F5.  That chip is supported by 
 * additional digital components, programmed through the Digital Output
 * Register (DOR) on port 0x3F2.
 *
 * <p>
 * There are a few tricky details to this construction: <ul>
 * <li> The ready signal from the drive is ignored; the ready input to
 *      the 8272 is tied to logical 1.
 * <li> The drive select signals generated by the 8272 are ignored;
 *      drive select is determined by the Digital Output Register.
 *      Thus, if the 8272 is instructed to read from drive 0 but drive 1 is
 *      enabled in the DOR, data will actually be read from drive 1.
 *      The simulation does not take this detail into account; the 8272
 *      command words determine which drive is addressed in the simulation.
 * </ul>
 *
 * Timing of the simulation is not realistic; in general the simulated
 * controller responds much faster than a real controller.
 */
public class FloppyController implements IOPortHandler, DmaDevice
{

    protected static Logger log = Logger.getLogger("FloppyCtl");

    /** Command execution time (50 us, arbitrary value). */
    private static final long COMMANDDELAY = 50000;

    /** Time to transfer one byte of a sector in non-DMA mode (27 us, from 8272 spec). */
    private static final long BYTEDELAY = 27000;

    /** Time to transfer one sector in DMA mode (5 ms, arbitrary value). */
    private static final long SECTORDELAY = 5000000;

    /** Status register 0. */
    private byte regSt0;

    /** Digital output register. */
    private byte regDOR;

    /* Configuration */
    private byte ctlStepRateTime;
    private byte ctlHeadUnloadTime;
    private byte ctlHeadLoadTime;
    private boolean ctlNonDma;

    /** Current cylinder for each drive */
    private byte[] curCylinder;

    /** Bit mask of drives with a seek operation in progress */
    private byte driveSeeking;

    /** Bit mask of drives with a pending ready notification */
    private byte pendingReadyChange;

    /** Input buffer for command bytes */
    private byte[] commandbuf;
    private int commandlen;
    private int commandptr;
    private byte cmdCmd;
    private byte cmdDrive, cmdHead, cmdCylinder, cmdRecord, cmdEot;
    private boolean cmdMultitrack;

    /*
     * Controller state:
     * <ul>
     * <li> Idle:      commandptr == 0, databuf == null, resultbuf == null
     * <li> Command:   incomplete command, databuf == null, resultbuf == null
     * <li> Execution: complete command, databuf == null, resultbuf == null
     * <li> Transfer:  databuf != null, resultbuf == null
     * <li> Result:    resultbuf != null
     * </ul>
     *
     * Transitions:
     * <li> Idle -> Command:       CPU writes first command byte
     * <li> Idle -> Result:        CPU writes Sense Interrupt Status command or Invalid command
     * <li> Command -> Execution:  CPU writes last command byte
     * <li> Execution -> Result:   (after scheduled delay) Completed seek or aborted I/O command.
     * <li> Execution -> Transfer: (after scheduled delay) Start data transfer.
     * <li> Transfer -> Execution: Last byte of sector transferred, more sectors to come.
     * <li> Transfer -> Result:    Last byte transferred or DMA EOP, or timeout.
     * <li> Result -> Idle:        CPU reads last result byte
     * </ul>
     */
    private int state;
    private static final int STATE_IDLE          = 0;
    private static final int STATE_COMMAND       = 1;
    private static final int STATE_EXECUTE       = 2;
    private static final int STATE_TRANSFER_IN   = 3;
    private static final int STATE_TRANSFER_OUT  = 4;
    private static final int STATE_TRANSWAIT_IN  = 5;
    private static final int STATE_TRANSWAIT_OUT = 6;
    private static final int STATE_TRANSFER_EOP  = 7;
    private static final int STATE_RESULT        = 8;

    /** Output buffer for result bytes */
    private byte[] resultbuf;
    private int resultptr;

    /** Data buffer */
    private byte[] databuf;
    private int dataptr;

    /** Floppy disk drives */
    private DiskImage[] diskimg;

    /** Simulation scheduler */
    private Scheduler sched;

    /** Interrupt request signal */
    private InterruptRequest irq;

    /** DMA request signal */
    private DmaChannel dma;

    /* Command bytes */
    static final byte CMD_READ          = 0x06;
    static final byte CMD_READ_DEL      = 0x0c;
    static final byte CMD_WRITE         = 0x05;
    static final byte CMD_WRITE_DEL     = 0x09;
    static final byte CMD_READ_TRACK    = 0x02;
    static final byte CMD_READ_ID       = 0x0a;
    static final byte CMD_FORMAT        = 0x0d;
    static final byte CMD_SCAN_EQ       = 0x11;
    static final byte CMD_SCAN_LE       = 0x19;
    static final byte CMD_SCAN_GE       = 0x1d;
    static final byte CMD_CALIBRATE     = 0x07;
    static final byte CMD_SENSE_INT     = 0x08;
    static final byte CMD_SPECIFY       = 0x03;
    static final byte CMD_SENSE_DRIVE   = 0x04;
    static final byte CMD_SEEK          = 0x0f;


    /** Scheduled task for pending events. */
    private Scheduler.Task task = new Scheduler.Task() {
        public void run() {
            update();
        }
    };


    /** Constructs and initializes the floppy controller */
    public FloppyController(Scheduler sched,
                            InterruptRequest irq, DmaChannel dma)
    {
        this.sched = sched;
        this.irq = irq;
        this.dma = dma;
        curCylinder = new byte[4];
        diskimg = new DiskImage[4];
        regDOR = 0x0c;
        ctlStepRateTime = 0;
        ctlHeadUnloadTime = 0;
        ctlHeadLoadTime = 0;
        ctlNonDma = false;
        reset();
    }


    /**
     * Attaches a floppy disk image to a drive.
     * @param drive Disk drive number (0 ... 3)
     * @param img Disk image object, or null to detach an image
     */
    public void attachImage(int drive, DiskImage img)
    {
        log.debug((img == null ? "detach image" : "attach image") + " drive=" + drive);
        diskimg[drive] = img;
    }


    /** Resets the controller. */
    public void reset()
    {
        driveSeeking = 0;
        pendingReadyChange = 0;
        regSt0 = 0;
        commandbuf = new byte[9];
        commandptr = 0;
        resultbuf = null;
        databuf = null;
        if (irq != null) irq.raise(false);
        if (dma != null) dma.dmaRequest(false);
        state = STATE_IDLE;
        task.cancel();
    }


    /** Prepare to transfer next byte(s). */
    private void kickTransfer()
    {
        if (ctlNonDma) {
            // prepare to transfer next byte in non-DMA mode
            sched.runTaskAfter(task, BYTEDELAY);
            if (irq != null) irq.raise(true);
        } else {
            // prepare to transfer multiple bytes in DMA mode
            sched.runTaskAfter(task, SECTORDELAY);
            if (dma != null) dma.dmaRequest(true);
        }
    }


    /** Determines the length of a command from the first command byte. */
    private int commandLength()
    {
        switch (cmdCmd) {
          case CMD_READ:
          case CMD_READ_DEL:
          case CMD_WRITE:
          case CMD_WRITE_DEL:   return 9;
          case CMD_READ_TRACK:  return 9;
          case CMD_READ_ID:     return 2;
          case CMD_FORMAT:      return 6;
          case CMD_SCAN_EQ:
          case CMD_SCAN_LE:
          case CMD_SCAN_GE:     return 9;
          case CMD_CALIBRATE:   return 2;
          case CMD_SENSE_INT:   return 1;
          case CMD_SPECIFY:     return 3;
          case CMD_SENSE_DRIVE: return 2;
          case CMD_SEEK:        return 3;
          default:              return 1;
        }
    }


    /** Starts the execution of a command. */
    private void commandStart()
    {
        // Decode command parameters
        cmdMultitrack = ((commandbuf[0] & 0x80) != 0);
        cmdDrive = (byte)(commandbuf[1] & 3);
        cmdCylinder = commandbuf[2];
        cmdRecord = commandbuf[4];
        cmdEot = commandbuf[6];
        switch (cmdCmd) {
          case CMD_READ:
          case CMD_READ_DEL:
          case CMD_WRITE:
          case CMD_WRITE_DEL:
          case CMD_READ_TRACK:
          case CMD_SCAN_EQ:
          case CMD_SCAN_LE:
          case CMD_SCAN_GE:
            cmdHead = commandbuf[3]; break;
          default:
            cmdHead = (byte)((commandbuf[1] >> 2) & 1);
        }

        // Start execution
        switch (cmdCmd) {

          case CMD_READ:
          case CMD_READ_DEL:    // READ: go to EXECUTE state
            log.info("Read: DS=" + cmdDrive + " C=" + cmdCylinder +
                     " H=" + cmdHead +  " R=" + cmdRecord + " EOT=" + cmdEot +
                     " MT=" + cmdMultitrack);
            state = STATE_EXECUTE;
            sched.runTaskAfter(task, COMMANDDELAY);
            break;

          case CMD_WRITE:
          case CMD_WRITE_DEL:   // WRITE: go to EXECUTE state
            log.info("Write: DS=" + cmdDrive + " C=" + cmdCylinder +
                     " H=" + cmdHead +  " R=" + cmdRecord + " EOT=" + cmdEot +
                     " MT=" + cmdMultitrack);
            state = STATE_EXECUTE;
            sched.runTaskAfter(task, COMMANDDELAY);
            break;

          case CMD_READ_TRACK:  // READ TRACK: go to EXECUTE state
            log.info("Read Track: DS=" + cmdDrive + " C=" + cmdCylinder +
                     " H=" + cmdHead + " R=" + cmdRecord + " EOT=" + cmdEot);
            state = STATE_EXECUTE;
            sched.runTaskAfter(task, COMMANDDELAY);
            break;

          case CMD_READ_ID:     // READ ID: go to execute state
            log.info("Read Id: DS=" + cmdDrive + " H=" + cmdHead);
            state = STATE_EXECUTE;
            sched.runTaskAfter(task, COMMANDDELAY);
            break;

          case CMD_FORMAT:      // FORMAT: go to EXECUTE state
            log.info("Format: DS=" + cmdDrive);
            state = STATE_EXECUTE;
            sched.runTaskAfter(task, COMMANDDELAY);
            break;

          case CMD_SCAN_EQ:
          case CMD_SCAN_LE:
          case CMD_SCAN_GE:     // SCAN: go to EXECUTE state
            log.info("Scan: " +
              ((commandbuf[0] & 0x1f) == CMD_SCAN_EQ ? "EQ" :
               ((commandbuf[0] & 0x1f) == CMD_SCAN_LE ? "LE" : "GE")) +
              " DS=" + cmdDrive + " C=" + cmdCylinder + " H=" + cmdHead +
              " R=" + cmdRecord + " EOT=" + cmdEot + " MT=" + cmdMultitrack);
            state = STATE_EXECUTE;
            sched.runTaskAfter(task, COMMANDDELAY);
            break;

          case CMD_CALIBRATE:   // CALIBRATE: go to EXECUTE state
            log.info("Recalibrate: DS=" + cmdDrive);
            cmdCylinder = 0;
            driveSeeking |= (byte)(1 << cmdDrive);
            state = STATE_EXECUTE;
            sched.runTaskAfter(task, COMMANDDELAY);
            break;

          case CMD_SENSE_INT:   // SENSE INTERRUPT: respond immediately
            log.info("Sense Interrupt");
            if (irq != null) irq.raise(false);
            // Respond to a completed seek command.
            for (int i = 0; i < 4; i++)
                if ((driveSeeking & (1 << i)) != 0) {
                    driveSeeking &= (byte)(~(1 << i));
                    pendingReadyChange &= (byte)(~(1 << i));
                    commandEndSense((byte)(0x20 | i), curCylinder[i]);
                    return;
                }
            // Respond to a disk-ready change.
            for (int i = 0; i < 4; i++)
                if ((pendingReadyChange & (1 << i)) != 0) {
                    pendingReadyChange &= (byte)(~(1 << i));
                    commandEndSense((byte)(0xc0 | i), curCylinder[i]);
                    return;
                }
            // No pending interrupt condition; respond with invalid command.
            log.warn("No pending interrupt condition");
            commandEndSense((byte)0x80);
            break;

          case CMD_SPECIFY:     // SPECIFY: no response
            ctlStepRateTime =   (byte)((commandbuf[1] >> 4) & 0x0f);
            ctlHeadUnloadTime = (byte)(commandbuf[1] & 0x0f);
            ctlHeadLoadTime =   (byte)((commandbuf[2] >> 1) & 0x7f);
            ctlNonDma =         ((commandbuf[2] & 1) == 1);
            log.info("Specify: nondma=" + ctlNonDma);
            commandEndVoid();
            break;

          case CMD_SENSE_DRIVE: // SENSE DRIVE: respond immediately
            log.info("Sense Drive: DS=" + cmdDrive);
            byte st3 = (byte)(commandbuf[1] & 0x07);
            if (curCylinder[cmdDrive] == 0)
                st3 |= 0x10;        // track 0
            st3 |= 0x20;            // ready line is tied to true
            if (diskimg[cmdDrive] != null) {
                if (diskimg[cmdDrive].getNumHeads() > 1)
                    st3 |= 0x08;    // two side
                if (diskimg[cmdDrive].readOnly())
                    st3 |= 0x40;    // write protected
            }
            commandEndSense(st3);
            break;

          case CMD_SEEK:        // SEEK: go to EXECUTE state
            log.info("Seek: DS=" + cmdDrive + " NCN=" + cmdCylinder);
            driveSeeking |= (byte)(1 << cmdDrive);
            state = STATE_EXECUTE;
            sched.runTaskAfter(task, COMMANDDELAY);
            break;

          default:              // INVALID: respond immediately
            log.info("Invalid Command: " + Misc.byteToHex(commandbuf[0]));
            regSt0 = (byte)0x80;
            commandEndSense(regSt0);
            break;
        }
    }


    /** Next step in the execution of a command. */
    private void commandExecute()
    {
        log.debug("commandExecute");

        long offs;
        int n, k;

        // Handle Seek and Recalibrate commands.
        switch (cmdCmd) {
          case CMD_CALIBRATE:
          case CMD_SEEK:
            curCylinder[cmdDrive] = cmdCylinder;
            commandEndSeek();
            return;
        }

        // Check for NOT READY.
        if (diskimg[cmdDrive] == null) {
            log.warn("no floppy image attached DS=" + cmdDrive);
            if (state == STATE_EXECUTE) {
                // No floppy image attached at start of command; respond with NOT READY.
                commandEndIO(0x48, 0x00, 0x00);     // abnormal, not ready
            } else {
                // Drive changed ready state during command; respond with NOT READY.
                commandEndIO(0xc8, 0x00, 0x00);     // abnormal (ready change), not ready
            }
            return;
        }

        // Check for valid cylinder/head/sector numbers.
        switch (cmdCmd) {
          case CMD_READ:
          case CMD_READ_DEL:
          case CMD_WRITE:
          case CMD_WRITE_DEL:
          case CMD_READ_TRACK:
          case CMD_SCAN_EQ:
          case CMD_SCAN_LE:
          case CMD_SCAN_GE:

            // Check cylinder number.
            if ((cmdCylinder & 0xff) != curCylinder[cmdDrive]) {
                // Requested cylinder does not match current head position;
                // respond with NO DATA and WRONG CYLINDER.
                log.warn("wrong cylinder C=" + cmdCylinder);
                commandEndIO(0x40, 0x04, 0x10);     // abnormal, no data, wrong cylinder
                return;
            }

            // Check head number.
            if ((cmdHead & 0xff) >= diskimg[cmdDrive].getNumHeads()) {
                // Head out-of-range; respond with NOT READY
                log.warn("invalid head number H=" + cmdHead);
                commandEndIO(0x48, 0x00, 0x00);     // abnormal, not ready
                return;
            }

            if (cmdCmd == CMD_READ_TRACK)
                break;

            // Check sector number.
            if (cmdRecord == 0 || (cmdRecord & 0xff) > diskimg[cmdDrive].getNumSectors()) {
                // Sector out-of-range; respond with NO DATA.
                log.warn("invalid sector number R=" + cmdRecord);
                commandEndIO(0x40, 0x04, 0x00);     // abnormal, no data
                return;
            }

        }

        switch (cmdCmd) {

          case CMD_READ_DEL:
          case CMD_WRITE_DEL:
          case CMD_FORMAT:
            // Not implemented; respond with NO DATA and MISSING ADDRESS.
            log.warn("unsupported operation");
            commandEndIO(0x40, 0x05, 0x01);         // abnormal, no data, missing address
            break;

          case CMD_READ:
            // Read sector.
            databuf = new byte[512];
            offs = diskimg[cmdDrive].mapChsToOffset(cmdCylinder, cmdHead, cmdRecord);
            k = diskimg[cmdDrive].read(offs, databuf);
            if (k < 0) {
                // Read error; respond with DATA ERROR.
                commandEndIO(0x40, 0x20, 0x00);     // abnormal, data error
                return;
            }
            // Go to TRANSFER state.
            dataptr = 0;
            state = STATE_TRANSFER_OUT;
            kickTransfer();
            break;

          case CMD_WRITE:
            // Check for WRITE PROTECTED.
            if (diskimg[cmdDrive].readOnly()) {
                log.warn("attempt to write to write protected disk");
                commandEndIO(0x40, 0x02, 0x00);     // abnormal, write protected
                return;
            }
            // Go to TRANSFER state.
            databuf = new byte[512];
            dataptr = 0;
            state = STATE_TRANSFER_IN;
            kickTransfer();
            break;

          case CMD_READ_TRACK:
            // Read track.
            n = diskimg[cmdDrive].getNumSectors();
            if ((cmdEot & 0xff) < n) n = cmdEot & 0xff;
            databuf = new byte[n * 512];
            offs = diskimg[cmdDrive].mapChsToOffset(cmdCylinder, cmdHead, 1);
            k = diskimg[cmdDrive].read(offs, databuf);
            if (k < 0) {
                // Read error; respond with DATA ERROR.
                commandEndIO(0x40, 0x20, 0x00);     // abnormal, data error
                return;
            }
            // Go to TRANSFER state.
            dataptr = 0;
            state = STATE_TRANSFER_OUT;
            kickTransfer();
            break;

          case CMD_READ_ID:
            // Return current cylinder, sector 1.
            cmdCylinder = curCylinder[cmdDrive];
            cmdRecord = 1;
            commandEndIO(0x00, 0x00, 0x00);         // normal termination
            break;

          case CMD_SCAN_EQ:
          case CMD_SCAN_LE:
          case CMD_SCAN_GE:
            // Go to TRANSFER state.
            databuf = new byte[512];
            dataptr = 0;
            state = STATE_TRANSFER_IN;
            kickTransfer();
            break;

        }
    }


    /** Called when a buffer has been transferred (or EOP-ed). */
    private void commandTransferDone()
    {
        log.debug("commandTransferDone");

        long offs;
        int n, k;
        byte[] tmpbuf;
        boolean scanEq, scanLe, scanGe;
        byte st2 = 0x00;
        byte sectorStep = 1;

        switch (cmdCmd) {

          case CMD_READ:
            break;

          case CMD_WRITE:
            // Write sector.
            if (diskimg[cmdDrive] == null) {
                // No floppy image attached; respond with NOT READY.
                commandEndIO(0xc8, 0x00, 0x00);     // abnormal (ready change), not ready
                return;
            }
            offs = diskimg[cmdDrive].mapChsToOffset(cmdCylinder, cmdHead, cmdRecord);
            k = diskimg[cmdDrive].write(offs, databuf);
            if (k < 0) {
                // Write error; respond with DATA ERROR.
                commandEndIO(0x40, 0x20, 0x00);     // abnormal, data error
                return;
            }
            break;

          case CMD_READ_TRACK:
            // Track done.
            // Did we encounter a sector matching cmdRecord?
            n = (dataptr + 511) / 512;
            if (cmdRecord != 0 && (cmdRecord & 0xff) <= n)
                commandEndIO(0x00, 0x00, 0x00);     // normal termination
            else
                commandEndIO(0x00, 0x04, 0x00);     // normal termination, no data
            return;

          case CMD_SCAN_EQ:
          case CMD_SCAN_LE:
          case CMD_SCAN_GE:
            // Read sector from disk.
            if (diskimg[cmdDrive] == null) {
                // No floppy image attached; respond with NOT READY.
                log.warn("no disk image attached DS=" + cmdDrive);
                commandEndIO(0xc8, 0x00, 0x00);     // abnormal (ready change), not ready
                return;
            }
            offs = diskimg[cmdDrive].mapChsToOffset(cmdCylinder, cmdHead, cmdRecord);
            tmpbuf = new byte[512];
            k = diskimg[cmdDrive].read(offs, tmpbuf);
            if (k < 0) {
                // Read error; respond with DATA ERROR.
                commandEndIO(0x40, 0x20, 0x00);     // abnormal, data error
                return;
            }
            // Compare supplied data to on-disk data.
            scanEq = scanLe = scanGe = true;
            for (int i = 0; i < 512; i++)
                if ((databuf[i] & 0xff) < (tmpbuf[i] & 0xff))
                    scanEq = scanGe = false;
                else if ((databuf[i] & 0xff) > (tmpbuf[i] & 0xff))
                    scanEq = scanLe = false;
            if ( (cmdCmd == CMD_SCAN_EQ && scanEq) ||
                 (cmdCmd == CMD_SCAN_LE && scanLe) ||
                 (cmdCmd == CMD_SCAN_GE && scanGe) ) {
                // Scan condition met.
                st2 = (scanEq) ? (byte)0x08 : (byte)0x00; // if equal, set scan hit flag
                commandEndIO(0x00, 0x00, st2);      // normal termination
                return;
            }
            st2 = 0x04;                             // set scan not satisfied flag
            sectorStep = commandbuf[8];             // sector increment supplied by command word
            break;
        }

        if (dataptr == 512) {
            // Complete sector transferred; increment sector number.
            if (cmdRecord == cmdEot) {
                cmdRecord = sectorStep;
                if (cmdMultitrack)
                    cmdHead ^= 1;
                if (!cmdMultitrack || (cmdHead & 1) == 0)
                    cmdCylinder++;
            } else {
                cmdRecord += sectorStep;
            }
        }

        if ( state == STATE_TRANSFER_EOP ||
             (cmdRecord == 1 && (!cmdMultitrack || (cmdHead & 1) == 0)) ) {
            // Transferred last sector or got EOP.
            commandEndIO(0x00, 0x00, st2);          // normal termination
        } else {
            // Start transfer of next sector.
            commandExecute();
        }

    }


    /** Ends a command which does not return response data. */
    private void commandEndVoid()
    {
        log.debug("commandEndVoid");
        commandptr = 0;
        state = STATE_IDLE;
    }


    /** Ends a command which returns data without an IRQ signal. */
    private void commandEndSense(byte st)
    {
        log.debug("commandEndSense(" + Misc.byteToHex(st) + ")");
        resultbuf = new byte[1];
        resultbuf[0] = st;
        resultptr = 0;
        state = STATE_RESULT;
    }


    /** Ends a command which returns data without an IRQ signal. */
    private void commandEndSense(byte st, byte pcn)
    {
        log.debug("commandEndSense(" + Misc.byteToHex(st) + "," + Misc.byteToHex(pcn) + ")");
        resultbuf = new byte[2];
        resultbuf[0] = st;
        resultbuf[1] = pcn;
        resultptr = 0;
        state = STATE_RESULT;
    }


    /** Ends a command which returns no data but raises an IRQ signal. */
    private void commandEndSeek()
    {
        log.debug("commandEndSeek");
        commandptr = 0;
        state = STATE_IDLE;
        if (irq != null) irq.raise(true);
    }


    /** Ends a command which reports I/O status and raises an IRQ signal. */
    private void commandEndIO(int st0, int st1, int st2)
    {
        log.debug("commandEndIO(" + Misc.byteToHex(st0) + "," + Misc.byteToHex(st1) + "," + Misc.byteToHex(st2) + ")");
        resultbuf = new byte[7];
        regSt0 = (byte)(st0 | (commandbuf[1] & 7));
        resultbuf[0] = regSt0; 
        resultbuf[1] = (byte)st1;
        resultbuf[2] = (byte)st2;
        resultbuf[3] = cmdCylinder;
        resultbuf[4] = cmdHead;
        resultbuf[5] = cmdRecord;
        resultbuf[6] = 2; // always assume 512-byte sectors
        resultptr = 0;
        state = STATE_RESULT;
        if (irq != null) irq.raise(true);
    }


    /** Called from the scheduled task to handle the next step of a command. */
    private void update()
    {
        switch (state) {

          case STATE_EXECUTE:
            // Start/continue command execution.
            commandExecute();
            break;

          case STATE_TRANSFER_IN:
          case STATE_TRANSFER_OUT:
            // Timeout during I/O transfer; terminate command.
            log.info("transfer timeout");
            if (dma != null) dma.dmaRequest(false);
            // A real floppy controller would probably complete the current sector here.
            // But a timeout is in itself a pretty serious error, so we don't care so much
            // about the exact behaviour. (TODO)
            commandEndIO(0x48, 0x10, 0x00);         // abnormal, overrun
            break;

          case STATE_TRANSWAIT_IN:
          case STATE_TRANSWAIT_OUT:
            if (dataptr < databuf.length) {
                // Continue the current transfer.
                state = (state == STATE_TRANSWAIT_IN) ? STATE_TRANSFER_IN :
                                                        STATE_TRANSFER_OUT;
                kickTransfer();
            } else {
                // Transfer completed.
                commandTransferDone();
            }
            break;

          case STATE_TRANSFER_EOP:
            // Transfer EOP-ed.
            commandTransferDone();
            break;

        }
    }


    /** Returns current value of main status register. */
    private byte getMainStatus()
    {
        byte stmain;
        switch (state) {
          case STATE_IDLE:
            stmain = (byte)0x80;            // RQM, WR
            break;
          case STATE_COMMAND:
            stmain = (byte)0x90;            // RQM, WR, CMDBSY
            break;
          case STATE_EXECUTE:
            stmain = (byte)0x10;            // CMDBSY
            break;
          case STATE_TRANSFER_IN:
            stmain = (byte)0x10;            // CMDBSY
            if (ctlNonDma)
                stmain |= (byte)0xc0;       // RQM, WR, NONDMA
            break;
          case STATE_TRANSFER_OUT:
            stmain = (byte)0x10;
            if (ctlNonDma)
                stmain |= (byte)0xe0;       // RQM, RD, NONDMA
            break;
          case STATE_RESULT:
            stmain = (byte)0xd0;            // RQM, RD, CMDBSY
            break;
          default:
            stmain = (byte)0x10;            // CMDBSY
            if (ctlNonDma)
                stmain |= 0x20;             // NONDMA
            break;
        }
        stmain |= driveSeeking;             // bit mask of seeking drives
        return stmain;
    }


    /** Handles I/O write request from the Cpu. */
    public void outb(int v, int port)
    {
        if ((port & 3) == 2) {
            // write to digital output register
            log.debug("DOR: " + Misc.byteToHex(v));
            if ((v & 0x04) == 0) {
                // reset controller
                reset();
            } else if ((regDOR & 0x04) == 0) {
                // awake from reset condition; send disk-ready notification
                log.info("Reset");
                if (irq != null) irq.raise(true);
                pendingReadyChange = 0x0f;
            }
            regDOR = (byte)v;
        } else if ((port & 3) == 1) {
            // write to data register
            if (state == STATE_IDLE) {
                // CPU writes first command byte
                state = STATE_COMMAND;
                cmdCmd = (byte)(v & 0x1f);
                commandlen = commandLength();
            }
            if (state == STATE_COMMAND) {
                // CPU writes a command byte
                commandbuf[commandptr] = (byte)v;
                commandptr++;
                if (commandptr == commandlen)
                    commandStart();
            } else if (state == STATE_TRANSFER_IN && ctlNonDma) {
                // CPU writes data byte
                databuf[dataptr] = (byte)v;
                dataptr++;
                state = STATE_TRANSWAIT_IN;
                if (irq != null) irq.raise(false);
            } else {
                // unexpected write
                log.warn("unexpected write to data register");
            }
        } else {
            // write to unknown port
            log.warn("OUTB " +
                     Misc.byteToHex(v) + " -> " + Misc.wordToHex(port));
        }
}


    /** Handles I/O read request from the Cpu */
    public int inb(int port)
    {
        if ((port & 3) == 0) {
            // main status register
            return getMainStatus();
        } else if ((port & 3) == 1) {
            // read from data register
            if (irq != null) irq.raise(false);
            if (state == STATE_RESULT) {
                // read next byte of result
                int v = resultbuf[resultptr] & 0xff;
                resultptr++;
                if (resultptr == resultbuf.length) {
                    // end of result phase
                    commandptr = 0;
                    databuf = resultbuf = null;
                    dataptr = resultptr = 0;
                    state = STATE_IDLE;
                    log.debug("idle");
                }
                return v;
            } else if (state == STATE_TRANSFER_OUT && ctlNonDma) {
                // read next I/O byte in non-DMA mode
                int v = databuf[dataptr] & 0xff;
                dataptr++;
                state = STATE_TRANSWAIT_OUT;
                return v;
            }
        }
        // unexpected read
        log.warn("INB " + Misc.wordToHex(port));
        return 0xff;
    }


    /** Handles a DMA read transfer (when executing a disk write command). */
    public void dmaRead(byte v)
    {
        if (state == STATE_TRANSFER_IN) {
            databuf[dataptr] = v;
            dataptr++;
            if (dataptr == databuf.length) {
                state = STATE_TRANSWAIT_IN;
                if (dma != null) dma.dmaRequest(false);
            }
        } else {
            log.warn("unexpected dmaRead");
        }
    }


    /** Handles a DMA write transfer (when executing a disk read command). */
    public byte dmaWrite()
    {
        if (state == STATE_TRANSFER_OUT) {
            byte v = databuf[dataptr];
            dataptr++;
            if (dataptr == databuf.length) {
                state = STATE_TRANSWAIT_OUT;
                if (dma != null) dma.dmaRequest(false);
            }
            return v;
        } else {
            log.warn("unexpected dmaWrite");
            return (byte)0xff;
        }
    }


    /** Handles EOP signal from the DMA controller. */
    public void dmaEop()
    {
        log.debug("dmaEop");
        switch (state) {
          case STATE_TRANSFER_IN:
          case STATE_TRANSFER_OUT:
          case STATE_TRANSWAIT_IN:
          case STATE_TRANSWAIT_OUT:
            // Terminate command
            if (dma != null) dma.dmaRequest(false);
            state = STATE_TRANSFER_EOP;
            break;
          default:
            log.warn("unexpected dmaEop");
        }
    }

}

/* end */
